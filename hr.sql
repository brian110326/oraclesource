-- employees 테이블에서 전체 내용을 조회
SELECT
	*
FROM
	EMPLOYEES e ;

-- first name, last name, job id
SELECT
	FIRST_NAME ,
	LAST_NAME ,
	JOB_ID
FROM
	EMPLOYEES e ;
	
-- 사원번호가 176인 사람의 LAST NAME과 DEPARTMENT_ID조회
SELECT
	LAST_NAME ,
	DEPARTMENT_ID
FROM
	EMPLOYEES e
WHERE
	EMPLOYEE_ID = 176

-- 연봉이 12000 이상 되는 직원들의 LAST_NAME과 SALARY 조회
SELECT
	LAST_NAME ,
	SALARY 
FROM
	EMPLOYEES e
WHERE
	SALARY >= 12000

-- 연봉이 5000에서 12000의 범위 이외인 사람들 LASTNAME SALARY조회
SELECT
	LAST_NAME ,
	SALARY
FROM
	EMPLOYEES e
WHERE
	SALARY NOT BETWEEN 5000 AND 12000;

-- 부서번호가 20 혹은 50 부서에서 근무하는 사원 LAST_NAME, DEPT_ID조회
-- last name, dept id 오름차순
SELECT
	LAST_NAME ,
	DEPARTMENT_ID
FROM
	EMPLOYEES e
WHERE
	DEPARTMENT_ID IN (20, 50)
ORDER BY LAST_NAME, DEPARTMENT_ID;

-- 커미션을 버는 모든 사원들의 LAST_NAME, SALARY, COMMISION_PCT조회
SELECT
	LAST_NAME,
	SALARY,
	COMMISSION_PCT
FROM
	EMPLOYEES e
WHERE
	COMMISSION_PCT IS NOT NULL
ORDER BY SALARY DESC , COMMISSION_PCT DESC;

--salary가 2500,3500,7000이 아니며 Job이 sa_rep나 ST_CLERK사원조회
SELECT
	*
FROM
	EMPLOYEES e
WHERE
	SALARY NOT IN (2500, 3500, 7000)
	AND JOB_ID IN ('SA_REP', 'ST_CLERK');

-- 2017-01-01~ 2017-12-31사이에 고용된 사원들의 LAST_NAME, EMPLOYEE_ID, HIRED_DATE
SELECT LAST_NAME, EMPLOYEE_ID, HIRE_DATE
FROM EMPLOYEES e
WHERE HIRE_DATE >= '2017-01-01' AND HIRE_DATE <= '2017-12-31';

SELECT
	LAST_NAME,
	EMPLOYEE_ID,
	HIRE_DATE
FROM
	EMPLOYEES e
WHERE
	HIRE_DATE BETWEEN '2017-01-01' AND '2017-12-31';

--부서번호가 20, 50 부서에서 근무하고 연봉이 5000~12000사이인 사원들의 LAST_NAME, SALARY 조회
SELECT LAST_NAME, SALARY
FROM EMPLOYEES e 
WHERE DEPARTMENT_ID IN (20,50) AND SALARY BETWEEN 5000 AND 12000
ORDER BY SALARY ;

-- 2017년에 고용된 사원들 LAST_NAME,  EMPLOYEE_ID, HIRE_DATE 조회
SELECT LAST_NAME,  EMPLOYEE_ID, HIRE_DATE
FROM EMPLOYEES e 
WHERE EXTRACT (YEAR FROM HIRE_DATE) = 2017
ORDER BY HIRE_DATE DESC;

-- 연봉이 5000에서 12000의 범위 이외인 사람들 LASTNAME SALARY조회
SELECT
	LAST_NAME ,
	SALARY
FROM
	EMPLOYEES e
WHERE
	SALARY NOT BETWEEN 5000 AND 12000;



-- 2일차(1/24)
-- LAST_NAME에 u가 포함되는 사원들 사번, lastname 조회
SELECT LAST_NAME, EMPLOYEE_ID 
FROM EMPLOYEES e
WHERE LAST_NAME LIKE '%u%';

-- LAST_NAME의 4번째 문자가 a인 사원들 사번, lastname 조회
SELECT EMPLOYEE_ID , LAST_NAME  
FROM EMPLOYEES e
WHERE LAST_NAME LIKE '___a%'
ORDER BY LAST_NAME ;

-- LAST_NAME에 a e 글자 들어있는 사원 사번, lastname, lastname오름차순
SELECT EMPLOYEE_ID , LAST_NAME  
FROM EMPLOYEES e 
WHERE LAST_NAME LIKE '%a%' AND LAST_NAME LIKE  '%e%'
ORDER BY LAST_NAME ;

SELECT EMPLOYEE_ID , LAST_NAME  
FROM EMPLOYEES e 
WHERE LAST_NAME LIKE '%a%e%' OR  LAST_NAME LIKE  '%e%a%'
ORDER BY LAST_NAME ;

-- LAST_NAME에 a 혹은 e 글자 들어있는 사원 사번, lastname, lastname오름차순
SELECT EMPLOYEE_ID , LAST_NAME  
FROM EMPLOYEES e 
WHERE LAST_NAME LIKE '%a%' OR  LAST_NAME LIKE  '%e%'
ORDER BY LAST_NAME ;

-- 
SELECT *
FROM EMPLOYEES e ;

-- MANAGER_ID가 없는 사원들의 LAST_NAME , JOB_ID조회
SELECT LAST_NAME , JOB_ID
FROM EMPLOYEES e
WHERE MANAGER_ID IS NULL;

-- ST_CLERK인 JOB_ID를 가진 사원이 없는 부서 ID조회(단, 부서번호가 NULL인 사원 제외)
SELECT DISTINCT DEPARTMENT_ID 
FROM EMPLOYEES e
WHERE JOB_ID != 'ST_CLERK' AND DEPARTMENT_ID IS NOT NULL;


-- COMMISSION_PCT가 NULL이 아닌 사원들 중 COMMISSION = SALARY * COMMISSION_PCT
-- 를 구하여 EMPLOYYEE_ID, FIRST_NAME, JOB_ID, COMISSION 조회
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, SALARY * COMMISSION_PCT AS COMMISSION
FROM EMPLOYEES e
WHERE COMMISSION_PCT IS NOT NULL;

-- NULL * 숫자 = NULL
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, SALARY, COMMISSION_PCT , SALARY * COMMISSION_PCT AS COMMISSION
FROM EMPLOYEES e;


-- FIRST_NAME이 'Curtis'인 사원의 first_name, last_name, email,phone_number, job_id를 조회
-- 단 job_id결과는 소문자로 출력
SELECT FIRST_NAME ,LAST_NAME ,EMAIL ,PHONE_NUMBER ,LOWER(JOB_ID) AS JOB_ID
FROM EMPLOYEES e
WHERE FIRST_NAME = 'Curtis';

-- 부서번호가 60,70,80,90 인 사원들의 employee_id, first_name, hire_date, job_id 조회
-- 단, job_id가 IT_PROG인 사원의 경우 프로그래머로 변경하여 출력한다.
SELECT EMPLOYEE_ID , FIRST_NAME , HIRE_DATE , REPLACE(JOB_ID, 'IT_PROG', '프로그래머')
FROM EMPLOYEES e
WHERE DEPARTMENT_ID IN (60,70,80,90);

--job_id가 AD_PRES, PU_CLERK인 사원들의 employee_id, first_name, job_id 조회
-- 단, 사원명은 first_name과 last_name을 공백을 포함하여 연결
-- 'abc' 'def' => 'abc def'
SELECT EMPLOYEE_ID , CONCAT(FIRST_NAME,CONCAT(' ',LAST_NAME)) AS NAME  , JOB_ID 
FROM EMPLOYEES e 
WHERE JOB_ID IN ('AD_PRES','PU_CLERK');


-- 3일차(1/25)
-- TRUNC사용해서 해보기 salary에서 특정숫자를 나누어보기
SELECT
	LAST_NAME ,
	SALARY,
	CASE
		WHEN SALARY BETWEEN 0 AND 1999 THEN 0
		WHEN SALARY BETWEEN 2000 AND 3999 THEN 0.09
		WHEN SALARY BETWEEN 4000 AND 5999 THEN 0.2
		WHEN SALARY BETWEEN 6000 AND 7999 THEN 0.3
		WHEN SALARY BETWEEN 8000 AND 9999 THEN 0.4
		WHEN SALARY BETWEEN 10000 AND 11999 THEN 0.42
		WHEN SALARY BETWEEN 12000 AND 13999 THEN 0.44
		WHEN SALARY >= 14000 THEN 0.45
	END AS TAX_RATE
FROM
	EMPLOYEES e
WHERE
	DEPARTMENT_ID = 80;


-- 최대 연봉 - 최소연봉 조회
SELECT MAX(SALARY) - MIN(SALARY) AS GAP 
FROM EMPLOYEES e ;

-- 매니저로 근무하는 사원들의 총 수 조회(매니저번호 중복 제거)
SELECT COUNT(DISTINCT MANAGER_ID)  
FROM EMPLOYEES e ;

-- 부서별 직원수 구하기 , 부서번호의 오름차순
SELECT DEPARTMENT_ID  , COUNT(EMPLOYEE_ID) AS 직원수 
FROM EMPLOYEES e
GROUP BY DEPARTMENT_ID
ORDER BY DEPARTMENT_ID ;

-- 부서별 평균 급여, 부서번호의 오름차순
SELECT DEPARTMENT_ID , AVG(SALARY) 
FROM EMPLOYEES e
GROUP BY DEPARTMENT_ID 
ORDER BY DEPARTMENT_ID ;

-- 동일한 직무를 가진 사원들의 총 수 조회
SELECT JOB_ID  , COUNT(EMPLOYEE_ID) AS 사원수 
FROM EMPLOYEES e
GROUP BY JOB_ID
ORDER BY 사원수 ;

-- 1.매니저가 관리하는 사원들 중에서 최소급여 조회, 6000이상것만, 매니저 없는 사람 제외
SELECT MANAGER_ID , MIN(SALARY) AS MIN_SAL
FROM EMPLOYEES e
WHERE MANAGER_ID IS NOT NULL 
GROUP BY MANAGER_ID 
HAVING MIN(SALARY) > 6000; 


-- 2.자신의 담당 매니저의 고용일보다 빠른 입사자 찾기
SELECT e1.HIRE_DATE, e1.LAST_NAME, e2.MANAGER_ID, e2.HIRE_DATE  
FROM EMPLOYEES e1 JOIN EMPLOYEES e2 ON e1.MANAGER_ID = e2.EMPLOYEE_ID
WHERE e1.HIRE_DATE < e2.HIRE_DATE ;


-- 3.도시 이름이 T로 시작하는 지역에 사는 사원들의 사번, last_name, 부서번호 조회
-- 도시명은 LOCATIONS 테이블
SELECT
	e.EMPLOYEE_ID , e.LAST_NAME , e.DEPARTMENT_ID , l.CITY 
FROM
	EMPLOYEES e
JOIN DEPARTMENTS d ON
	e.DEPARTMENT_ID = d.DEPARTMENT_ID
JOIN LOCATIONS l ON 
	d.LOCATION_ID = l.LOCATION_ID
WHERE SUBSTR(l.CITY , 1, 1) = 'T'; 


-- 4.위치 아이디가 1700인 사원들의 lastname, 부서번호, 연봉 조회
SELECT
	e.LAST_NAME , e.DEPARTMENT_ID , e.SALARY 
FROM
	EMPLOYEES e
JOIN DEPARTMENTS d ON
	e.DEPARTMENT_ID = d.DEPARTMENT_ID
JOIN LOCATIONS l ON 
	d.LOCATION_ID = l.LOCATION_ID
WHERE l.LOCATION_ID = 1700;


-- 5.부서명, 위치ID, 각부서별 사원수, 각 부서별 평균 연봉 조회
-- 평균 연봉은 소수 2자리까지만
SELECT
	d.DEPARTMENT_NAME , l.LOCATION_ID , COUNT(e.EMPLOYEE_ID) AS 사원수, ROUND(AVG(e.SALARY),2) AS 평균연봉  
FROM
	DEPARTMENTS d
JOIN EMPLOYEES e ON
	d.DEPARTMENT_ID = e.DEPARTMENT_ID
JOIN LOCATIONS l ON
	d.LOCATION_ID = l.LOCATION_ID
GROUP BY d.DEPARTMENT_NAME , l.LOCATION_ID ;


-- 6.Executive 부서에 근무하는 사원들의 부서번호, last name, job_id 조회
SELECT d.DEPARTMENT_ID , e.LAST_NAME , e.JOB_ID 
FROM DEPARTMENTS d JOIN EMPLOYEES e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID
WHERE d.DEPARTMENT_NAME = 'Executive';


-- 7.각 사원별 소속 부서에서 자신보다 늦게 고용되었으나 많은 연봉을 받는 사원이 존재하는
-- 사원들의 이름조회(이름은 firstname과 lastname을 결합하여 하나로 나오게)
-- 부서번호, 결합된 이름, salary, hire_date 출력
SELECT DISTINCT e1.DEPARTMENT_ID, e1.FIRST_NAME || ' ' || e1.LAST_NAME AS NAME , e1.SALARY, e1.HIRE_DATE
FROM EMPLOYEES e1 JOIN EMPLOYEES e2 ON e1.DEPARTMENT_ID = e2.DEPARTMENT_ID
WHERE e1.HIRE_DATE < e2.HIRE_DATE AND e1.SALARY < e2.SALARY;

-- 4일차(1/26)
-- LAST_NAME에 u가 포함되는 사원들과 동일 부서에 근무하는 사원들의 사번 및 last_name 조회
-- 사번 오름차순
SELECT  EMPLOYEE_ID , LAST_NAME 
FROM EMPLOYEES e
WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID FROM EMPLOYEES e WHERE LAST_NAME LIKE '%u%')
ORDER BY EMPLOYEE_ID ;

-- 기존의 직업을 여전히 가지고 있는 사원들의 사번 및 job_id 조회
SELECT e.EMPLOYEE_ID ,e.JOB_ID 
FROM EMPLOYEES e
WHERE (e.EMPLOYEE_ID ,e.JOB_ID) IN (SELECT jh.EMPLOYEE_ID, jh.JOB_ID FROM JOB_HISTORY jh);

-- SELECT절에 서브쿼리넣어보기
-- 각 직무별 연봉 총합 및 각 부서별 연봉 총합 조회
-- select절 서브쿼리 연습용, 굳이 이렇게까지는 X
SELECT JOB_ID , (SELECT SUM(SALARY)  FROM EMPLOYEES e2 WHERE DEPARTMENT_ID = 10 AND e.JOB_ID = e2.JOB_ID ) AS DEPT10 
FROM EMPLOYEES e 
GROUP BY JOB_ID
ORDER BY JOB_ID ;





-- 연습문제용(못푼것은 !!표시)
-- JOB_ID가 SA_MAN인 사원들의 최대 연봉보다 높게 받는 사원들의 LAST_NAME, JOB_ID, SALARY 조회
SELECT LAST_NAME , JOB_ID , SALARY 
FROM EMPLOYEES e 
WHERE SALARY > (SELECT MAX(SALARY) FROM EMPLOYEES e2 WHERE JOB_ID= 'SA_MAN');


-- 커미션을 버는 사원들의 부서와 연봉이 동일한 사원들의 LAST_NAME, 부서번호, 연봉 조회
SELECT LAST_NAME , DEPARTMENT_ID , SALARY 
FROM EMPLOYEES e
WHERE (DEPARTMENT_ID , SALARY) IN (SELECT DEPARTMENT_ID , SALARY  FROM EMPLOYEES e2 WHERE COMMISSION_PCT IS NOT NULL) 

-- !!회사 전체 평균 연봉보다 더 많이 버는 사원들 중 LAST_NAME에 u 가 있는 사원들이 근무하는 부서에서 근무하는
-- 사원들의 사번, LAST_NAME, 부서번호, 연봉 조회
SELECT EMPLOYEE_ID ,LAST_NAME , DEPARTMENT_ID , SALARY 
FROM EMPLOYEES e 
WHERE DEPARTMENT_ID IN (
SELECT DISTINCT DEPARTMENT_ID 
FROM EMPLOYEES e
WHERE SALARY > (SELECT AVG(SALARY) FROM EMPLOYEES e2 ) AND LAST_NAME LIKE '%u%');

-- !!각 부서별 평균 연봉보다 더 받는 동일 부서 근무사원들의 LAST_NAME, 부서번호, 연봉 조회
-- 부서별 연봉을 기준으로 정렬
SELECT e1.LAST_NAME , e1.DEPARTMENT_ID , e1.SALARY , e2.DEPT_SAL_AVG 
FROM EMPLOYEES e1, (SELECT DEPARTMENT_ID, AVG(SALARY) AS DEPT_SAL_AVG
FROM EMPLOYEES e
GROUP BY DEPARTMENT_ID) e2 
WHERE e1.DEPARTMENT_ID = e2.DEPARTMENT_ID AND e1.SALARY >  e2.DEPT_SAL_AVG
ORDER BY DEPARTMENT_ID ;


-- last name이 Davies 인 사람보다 후에 고용된 사원들의 last name, hire date 조회
SELECT LAST_NAME , HIRE_DATE 
FROM EMPLOYEES e
WHERE HIRE_DATE > (SELECT HIRE_DATE  FROM EMPLOYEES e2 WHERE LAST_NAME = 'Davies');

-- last name이 King인 사원을 매니저로 두고 있는 모든 사원들의 last name, salary 조회
SELECT LAST_NAME , SALARY 
FROM EMPLOYEES e
WHERE MANAGER_ID IN (SELECT EMPLOYEE_ID  FROM EMPLOYEES e2 WHERE LAST_NAME = 'King');


-- last name이 Kochhar인 사원과 동일한 연봉 및 커미션을 버는 사원들의 last name, 부서번호, salary 조회
-- Kochhar은 제외한다
SELECT LAST_NAME , DEPARTMENT_ID , SALARY 
FROM EMPLOYEES e
WHERE (SALARY, COMMISSION_PCT) IN (SELECT SALARY , NVL(COMMISSION_PCT, 0)  FROM EMPLOYEES e2 WHERE LAST_NAME = 'Kochhar')
AND e.LAST_NAME != 'Kochhar';


--!! 부서가 위치한 국가 ID, 국가 이름 조회
--countries 테이블과 locations, departments 이용
SELECT COUNTRY_ID , COUNTRY_NAME 
FROM COUNTRIES c 
WHERE COUNTRY_ID IN (SELECT l.COUNTRY_ID 
FROM LOCATIONS l ,(SELECT LOCATION_ID 
FROM DEPARTMENTS d) D
WHERE l.LOCATION_ID = D.LOCATION_ID)

-- !!총 사원 수 및 2013~2016년도 별 고용된 사원들의 총 수를 조회
-- 올려준 소스코드 확인해보기(뭔가 제대로 쓴거같은데....)
SELECT
	DISTINCT 
	(
	SELECT
		COUNT(EMPLOYEE_ID)
	FROM
		EMPLOYEES e2) AS '총 사원수',
	(
	SELECT
		COUNT(EMPLOYEE_ID)
	FROM
		EMPLOYEES
	WHERE
		TO_CHAR(HIRE_DATE, 'YYYY')= '2013') AS '2013',
	(
	SELECT
		COUNT(EMPLOYEE_ID)
	FROM
		EMPLOYEES
	WHERE
		TO_CHAR(HIRE_DATE, 'YYYY')= '2014') AS '2014',
	(
	SELECT
		COUNT(EMPLOYEE_ID)
	FROM
		EMPLOYEES
	WHERE
		TO_CHAR(HIRE_DATE, 'YYYY')= '2015') AS '2015',
	(
	SELECT
		COUNT(EMPLOYEE_ID)
	FROM
		EMPLOYEES
	WHERE
		TO_CHAR(HIRE_DATE, 'YYYY')= '2016') AS '2016',
FROM
	EMPLOYEES e ;



-- !!위치 ID 가 1700인 사원들의 연봉과 커미션을 추출한 뒤, 추출된 사원들의 연봉과 커미션이
--동일한 사원정보 조회
--사원번호, 이름(first + last name), 부서번호, 급여 출력
SELECT EMPLOYEE_ID , FIRST_NAME || ' ' || LAST_NAME AS NAME , DEPARTMENT_ID , SALARY 
FROM EMPLOYEES e 
WHERE (SALARY , NVL(COMMISSION_PCT,0))  IN (
SELECT SALARY , NVL(COMMISSION_PCT,0) 
FROM EMPLOYEES e 
WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID 
FROM DEPARTMENTS d  
WHERE d.LOCATION_ID = 1700));


-- 5일차
SELECT *
FROM EMPLOYEES e 
WHERE FIRST_NAME = 'Jack';

-- 테이블 생성 - 구조, 데이터 복사
CREATE TABLE idx_employees AS SELECT DISTINCT FIRST_NAME, LAST_NAME, HIRE_DATE FROM EMPLOYEES e ;

-- index 생성
CREATE INDEX idx_name ON idx_employees(FIRST_NAME);

-- index 사용해서 조회 => range scan
SELECT *
FROM idx_employees
WHERE FIRST_NAME = 'Jack';


-- 6일차




























